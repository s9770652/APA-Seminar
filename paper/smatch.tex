\section{SMatch}
\label{sec:smatch}

In the case of an equal number of agents and items, \ie{} \(\abs{\agents} = n = m = \abs{\goods}\), the \emph{additive} \NSW{} can be solved exactly by finding a maximum matching on a bipartite graph with the sets of agents and of items as its parts;
as weight of the edge between agent \(i\) and item \(j\), use \(\weight \log \valuations[j]\), that is the weighted valuation of item \(j\) by agent \(i\) in the \emph{logarithmic} Nash social welfare.
Should there be more items than agents, then it would be obvious to just repeatedly find a maximum matching and assign the items accordingly until all items are allocated.
The flaw of this idea is that such a greedy algorithm only considers the valuations of items in the current matching and perhaps the valuations of items already assigned.
As the example in \cref{fig:allocation} demonstrates, this leads to an algorithm with an approximation factor dependent on the number \(m\) of items.\todo{What is the factor?}
The geometric mean of the \NSW{} favours allocations with similar valuations\todo{stimmt das?}, wherefore it may be beneficial for an agent to leave items to other agents if those agents cannot expect many more valuable items in the future.

\begin{figure*}
	\tikzset{
		lbl/.style = {},
		agent/.style = {draw, circle},
		item/.style = {draw, rectangle},
		dots/.style = {},
		weight/.style = {font=\small},
		edgeopt/.style = {},
		edgealg/.style = {},
		edgegry/.style = {},
		node distance=10mm and 27mm,
	}
	\def\allocationexample{
		\begin{tikzpicture}
			% items
			\node[item, label={[lbl]above:\(\goods\)}] (i1)                       {1};
			\node[item]                                (i2)  [below=of i1]        {2};
			\node[item]                                (i3)  [below=of i2]        {3};
			\node[item]                                (im)  [below=of i3]        {\(m\)};
			\node[item]                                (im1) [below=of im]        {\(m+1\)};
			\node[dots]                                (id)  at ($(i3)!0.5!(im)$) {\(\vdots\)};
			% agents
			\node[agent, label={[lbl]above:\(\agents\)}] (a1) [left=of i1]  {1};
			\node[agent]                                 (a2) [left=of im1] {2};
			% valuations
			\draw[edgealg] (a1) to node[weight, pos=.43, below]      {\(m + \epsilon\)} (i1);
			\draw          (a1) to node[weight, pos=.42, below]      {\(1\)} (i2);
			\draw          (a1) to node[weight, pos=.37, below]      {\(1\)} (i3);
			\draw          (a1) to node[weight, pos=.30, below]      {\(1\)} (im);
			\draw[edgeopt] (a1) to node[weight, pos=.26, below left] {\(1\)} (im1);

			\draw[edgeopt] (a2) to node[weight, pos=.26, above left] {\(m\)} (i1);
			\draw[edgegry] (a2) to node[weight, pos=.30, above]      {\(0\)} (i2);
			\draw[edgegry] (a2) to node[weight, pos=.37, above]      {\(0\)} (i3);
			\draw[edgegry] (a2) to node[weight, pos=.42, above]      {\(0\)} (im);
			\draw[edgealg] (a2) to node[weight, pos=.48, above]      {\(1\)} (im1);
		\end{tikzpicture}
	}
	\centering
	\begin{subfigure}{0.31\textwidth}
		\allocationexample
		\caption{%
			problem instance
			\todo[info]{might delete if document in two columns â†’ unused edges in grey}
		}
	\end{subfigure}
	\hfil
	\begin{subfigure}{0.31\textwidth}
		\tikzset{
			edgealg/.style = {white},
			edgegry/.style = {white},
		}
		\allocationexample
		\caption{%
			\(\OPT = \sqrt{m \cdot m}\)
		}
	\end{subfigure}
	\hfil
	\begin{subfigure}{0.31\textwidth}
		\tikzset{
			edgeopt/.style = {white},
			edgegry/.style = {white},
		}
		\allocationexample
		\caption{%
			\(\ALG \leq \sqrt{(2m + \epsilon - 1) \cdot 1}\)
		}
	\end{subfigure}
	\caption{%
		Agent \(1\) values item \(1\) at \(m + \epsilon\), and all other items at \(1\).
		Agent \(2\) values item \(1\) at \(m\), item \(m+1\) at \(1\), and all other items at \(0\).
		In an optimal allocation, item \(1\) would be assigned to agent \(2\) and all other items to agent \(1\), resulting in a NSW of \(\sqrt{m \cdot m} = m\).
		A repeated maximum matching algorithm would greedily assign item \(1\) to agent \(1\) and item \(m+1\) to agent \(2\) in the first round.
		Even if all remaining items were going to be assigned to agent \(1\), the NSW will never surpass \(\sqrt{(2m + \epsilon - 1) \cdot 1} < \sqrt{2m}\).
		The approximation factor \(\alpha \approx \sqrt{m/2}\) therefore depends on the number of items.
	}
	\label{fig:allocation}
\end{figure*}

The algorithm \SMatch{}, described in \cref{alg:smatch}, eliminates the flaw by first gaining foresight of the valuations of items assigned after the first matching, achieving an approximation factor of \(2 n\) (cf. \cref{th:smatch} later on).
For a fixed agent \(i\), order the items in descending order of the valuations by agent \(i\) and denote the \(j\)-th most liked item by \(\goodsordered{j}\).
To obtain a well-defined order, items of equal rank are further ordered numerically.
\SMatch, too, does repeatedly match items.
During the first matching, however, the edge weights are defined as \(\weight \log\paren[\big]{ \valuations[j] + \remvalue/n } \) for an edge between agent \(i\) and item \(j\).
The addend \(\remvalue\) serves as estimation of the valuation of items assigned after the first matching and is defined as
\begin{equation}
	\label{eq:def_remvalue}
	\remvalue
	\coloneq \smashoperator{\min_{\substack{\genericset \subset \goods \\ \abs{\genericset} \leq 2n}}} \{ \valuations[\goods \setminus \genericset] \}
	= \valuations[ \goodsordered{2n+1}, \dots, \goodsordered{m} ].
\end{equation}
The set \(\genericset\) has less than \(2n\) elements only if there are less than \(2n\) items in total.
From the second matching onwards, the edge weights are defined as \(\weight \log\paren[\big]{ \valuations[j] + \valuations[\alloc] }\), where \(\alloc\) is the continuously updated set of items assigned to agent \(i\) in previous matchings.
The addend \(\valuations[\alloc]\) could lead to better allocations in applications, but does not improve the approximation factor asymptotically.

\begin{algorithm*}[t]
	\KwIn{%
		set \(\agents = \{ 1, \dots, n \}\) of agents with weights \(\weight \forall i \in \agents\),
		set \(\goods = \{ 1, \dots, m \}\) indivisible items,
		additive valuations \(\valuations \colon \powerset[\goods] \to \realposzero\) where \(\valuations[\genericset]\) is the valuation of agent \(i \in \agents\) for each item set \(\genericset \subset \goods\)}
	\KwOut{%
		\(\frac{1}{2n}\)-approximation \(\alloc[][] = (\alloc[][1], \dots, \alloc[][n])\) of an optimal allocation
	}

	\(\alloc \gets \emptyset \quad\forall i \in \agents\)\;
	\(\remvalue \gets \valuations[ \goodsordered{2n+1}, \dots, \goodsordered{m} ] \quad\forall i \in \agents\)\;
	\(\weights \gets \{\,  \weight \cdot \log\paren[\big]{ \valuations[j] + \remvalue/n } \given[\bigm] i \in \agents, j \in \goods \,\}\)\tct*{edge weights}
	\(\bipartitegraph \gets (\agents, \goods, \weights)\)\tct*{bipartite graph}
	\(\matching \gets \maxweightmatching(\bipartitegraph)\)\;
	\(\alloc \gets \{\, j \given (i, j) \in \matching \,\} \quad\forall i \in \agents\)\tct*{allocate according to matching}
	\(\goodsrem \gets \goods \setminus \{\, j \given (i, j) \in \matching \,\}\)\tct*{remove allocated goods}
	\While{\(\goodsrem \neq \emptyset\)}{
		\(\weights \gets \{\,  \weight \cdot \log\paren[\big]{ \valuations[j] + \valuations[\alloc] } \given[\bigm] i \in \agents, j \in \goodsrem \,\}\)\;
		\(\bipartitegraph \gets (\agents, \goodsrem, \weights)\)\;
		\(\matching \gets \maxweightmatching(\bipartitegraph)\)\;
		\(\alloc \gets \alloc \cup \{\, j \given (i, j) \in \matching \,\} \quad\forall i \in \agents\)\;
		\(\goodsrem \gets \goodsrem \setminus \{\, j \given (i, j) \in \matching \,\}\)\;
	}
	\Return{\(\alloc[][]\)}
	\caption{%
		\SMatch{} for the Asymmetric Additive \NSW{} problem
	}
	\label{alg:smatch}
\end{algorithm*}

For convenience, we order the items in the final allocation \(\alloc = \{\asgd{1}, \dots, \asgd{\alloclen}\}\) of agent \(i\) by the order in which they were assigned, so that item \(\asgd{t}\) is assigned after the \(t\)-th matching.
To calculate the approximation factor of \SMatch, we first need to establish a lower bound on the valuation of single items.
\begin{lemma}
	\label{lem:lower_bound_single_item}
	For each agent \(i\) and their final allocation \(\alloc = \{\asgd{1}, \dots, \asgd{\alloclen}\}\), the item \(\asgd{t}\) is worth at least as much as the overall \(tn\)-th most highly valued item \(\goodsordered{tn}\), \ie{} \(\valuations[\asgd{t}] \geq \valuations[\goodsordered{tn}]\), for all \(t = 1, \dots, \alloclen\).
\end{lemma}
\begin{proof}
	At the start of the \(t\)-th iteration, no more than \((t-1) n\) items out of the \(tn\) most highly valued items \(\goodsordered{1}, \dots, \goodsordered{tn}\) have been assigned in previous iterations since at most~\(n\) items are assigned in each iteration.
	During the \(t\)-th iteration, at most \(n-1\) more of those highly valued items could be assigned to all other agents \(i' \neq i\), leaving at least one item in \(\goodsordered{1}, \dots, \goodsordered{tn}\) unassigned.
	Since \(\valuations[\goodsordered{k}] \geq \valuations[\goodsordered{tn}]\) for all \(k \leq tn\) by definition of \(\goodsordered{\cdot}\), the lemma follows.
\end{proof}

We can now establish \(\remvalue/n = \valuations[ \goodsordered{2n+1}, \dots, \goodsordered{m} ]/n\) as lower bound on  the valuations of items assigned after the first matching.
\begin{lemma}
	\label{lem:lower_bound_later_items}
	\(\valuations[ \asgd{2}, \dots, \asgd{\alloclen} ] \geq \remvalue/n\).
\end{lemma}
\begin{proof}
	By \cref{lem:lower_bound_single_item} and definition of \(\goodsordered{\cdot}\), every item \(\asgd{t}\) is worth at least as much as each item \(\goodsordered{tn+k}\) with \(k \in \{0, \dots, n-1\}\) and, consequently, its valuation \(\valuations[\asgd{t}]\) is at least as high as the mean valuation \(\frac{1}{n} \valuations[ \goodsordered{tn}, \dots, \goodsordered{tn + n-1} ]\).
	Further, it holds \(\alloclen n + n \geq m \) since each agent receives items for at least \(\floor{\frac{m}{n}} \geq \frac{m}{n} - 1\) rounds.
	Together, this yields
	\begin{align}
		 \valuations[\asgd{2}, \dots, \asgd{\alloclen}]
		&= \sum_{t=2}^{\alloclen} \valuations[\asgd{t}]
		 \geq \sum_{t=2}^{\alloclen} \frac{1}{n} \valuations[ \goodsordered{tn}, \dots, \goodsordered{tn + n-1} ] \\
		&\geq \frac{1}{n} \valuations[ \goodsordered{2n}, \dots, \goodsordered{m-1} ]
		 \geq \frac{1}{n} \valuations[ \goodsordered{2n+1}, \dots, \goodsordered{m} ]
		 = \frac{\remvalue}{n}
	\end{align}
	with the last inequality stemming from \(\valuations[\goodsordered{2n}] \geq \valuations[\goodsordered{m}]\).
\end{proof}

This allows us to calculate a lower bound on the approximation factor of \SMatch.
\begin{theorem}
	\label{th:smatch}
	\SMatch{} has an approximation factor of \(2 n\).
\end{theorem}
\begin{proof}
	\Cref{lem:lower_bound_later_items} can be plugged into the logarithmic \NSW:
	\begin{align}
		\log \NSW(\alloc[][])
		&= \frac{1}{\sum_{i=1}^{n} \weight} \cdot \sum_{i=1}^{n} \weight \log \valuations[\asgd{1}, \dots, \asgd{\alloclen}] \\
		&= \frac{1}{\sum_{i=1}^{n} \weight} \cdot \sum_{i=1}^{n} \weight \log \paren[\big]{ \valuations[\asgd{1}] + \valuations[\asgd{2}, \dots, \asgd{\alloclen}] } \\
		&\geq \frac{1}{\sum_{i=1}^{n} \weight} \cdot \sum_{i=1}^{n} \weight \log \paren[\big]{ \valuations[\asgd{1}] + \remvalue / n } \label{eq:smatch_maximising}
	\end{align}
	Notice that the first matching of \SMatch{} maximises the sum in \cref{eq:smatch_maximising}.
	Thus, assigning all agents \(i\) their respective most highly valued item \(\asgd*{1}\) in an optimal allocation~\(\alloc* = \{ \asgd*{1}, \dots, \asgd*{\alloclen*} \}\) yields the even lower bound
	\begin{equation}
		\label{eq:smatch_approx_factor_lower_bound}
		\log \NSW(\alloc[][])
		\geq \frac{1}{\sum_{i=1}^{n} \weight} \cdot \sum_{i=1}^{n} \weight \log \paren[\big]{ \valuations[\asgd*{1}] + \remvalue / n }.
	\end{equation}
	Recall the definition of \(\remvalue\) from \cref{eq:def_remvalue}.
	Consider a slightly modified variant:
	\begin{equation}
		\remvalue = \smashoperator{\min_{\substack{\genericset \subset \goods \\ \abs{\genericset} \leq 2n}}} \{ \valuations[\goods \setminus \genericset] \}
		\textnormal{\quad or, alternatively,\quad}
		\remvalue = \valuations[\goods \setminus \genericset[i]]
		\textnormal{ with }
		\genericset[i] \coloneq \smashoperator{\argmin_{\substack{\genericset \subset \goods \\ \abs{\genericset} \leq 2n}}} \{ \valuations[\goods \setminus \genericset] \}
	\end{equation}
	Moreover, consider the set \(\genericset*[i]\) of the (at most) \(2n\) most highly valued items in the optimal allocation \(\alloc*\), \ie
	\begin{equation}
		\genericset*[i]
		\coloneq \smashoperator{\argmin_{\substack{\genericset \subset \goods \\ \abs{\genericset} \leq 2n}}} \{ \valuations[\alloc* \setminus \genericset] \}.
	\end{equation}
	We get the lower bound \(\valuations[\asgd*{1}] \geq \frac{1}{2 n} \valuations[\genericset*]\) from a similar argument as in the proof of \cref{lem:lower_bound_later_items}.
	Further, it holds \(\remvalue = \valuations[\goods \setminus \genericset[i]] \geq \valuations[\alloc* \setminus \genericset[i]] \geq \valuations[\alloc* \setminus \genericset*[i]]\).
	We can substitute these into \cref{eq:smatch_approx_factor_lower_bound} and prove the theorem thereby:
	\begin{align}
		\log \NSW(\alloc[][])
		&\geq \frac{1}{\sum_{i=1}^{n} \weight} \cdot \sum_{i=1}^{n} \weight \log \paren[\bigg]{ \frac{\valuations[\genericset*[i]]}{2 n} + \frac{\valuations[\alloc* \setminus \genericset*[i]]}{n} } \\
		&\geq \frac{1}{\sum_{i=1}^{n} \weight} \cdot \sum_{i=1}^{n} \weight \log \paren[\bigg]{ \frac{\valuations[\alloc*]}{2n} }
		 = \log \paren[\bigg]{\frac{\OPT}{2 n}}
	\end{align}
\end{proof}