\section{SMatch}

\begin{itemize}
	\item
	giving intuition why na\"{i}ve repeated maximum matching is not independent of \(m\) (cf. \Cref{fig:allocation})

	\item
	textual walk-through of algorithm

	\item
	giving intuition of lemmas used and theorem proof
	\todo[info, inline]{Proofs are short so this section might not be much shorter than the original one.}
	\todo[info, inline]{On second thought, this section could possibly be shortened even more by omitting the theory and getting merged with the introduction, depending on the length of the rest of the document.}
\end{itemize}

For a fixed agent \(i\), order the items in descending order of the valuations by agent \(i\) and denote the \(j\)-th most liked item by \(\goodsordered{j}\).\todo{probably to be mentionend earlier because of \(\remvalue\)}
\begin{lemma}
	\(\valuations[\asgd{t}] \geq \valuations[\goodsordered{tn}]\).
\end{lemma}

\begin{proof}
	At the start of the \(t\)-th iteration, at most \((t-1) n\) items out of the \(tn\) most highly valued items \(\goodsordered{1}, \dots, \goodsordered{tn}\) have been assigned in previous iterations since at most \(n\) items are assigned in each iteration.
	During the \(t\)-th iteration, at most \(n-1\) more of those highly valued items could be assigned to all other agents \(i' \neq i\), leaving at least one item in \(\goodsordered{1}, \dots, \goodsordered{tn}\) unassigned.
	Since \(\valuations[\goodsordered{k}] \geq \valuations[\goodsordered{tn}]\) for all \(k \leq i\) by definition, the lemma follows.
\end{proof}

\begin{lemma}
	\(\valuations[ \asgd{2}, \dots, \asgd{\alloclen} ] \geq \frac{\remvalue}{n}\).
\end{lemma}

\begin{proof}[Proof Sketch]
\end{proof}

\begin{algorithm*}[p]
	\KwIn{%
		set \(\agents = \{ 1, \dots, n \}\) of agents with weights \(\weight{i} \forall i \in \agents\),
		set \(\goods = \{ 1, \dots, m \}\) indivisible items,
		additive valuations \(\valuations \colon \powerset[\goods] \to \realpos\) where \(\valuations[\genericset]\) is the valuation of agent \(i \in \agents\) for each item set \(\genericset \subset \goods\)}
	\KwOut{%
		\(\frac{1}{2n}\)-approximation \(\alloc[][] = (\alloc[][1], \dots, \alloc[][n])\) of an optimal allocation
	}

	\(\alloc \gets \emptyset \quad\forall i \in \agents\)\;
	\(\remvalue \gets \valuations[\goodsint{2n+1}{m}] \quad\forall i \in \agents\)\;
	\(\weights \gets \{\,  \weight{i} \cdot \log\bigl( \valuations[j] + \frac{\remvalue}{n} \bigr) \given[\bigm] i \in \agents, j \in \goods \,\}\)\tct*{edge weights}
	\(\bipartitegraph \gets (\agents, \goods, \weights)\)\tct*{bipartite graph}
	\(\matching \gets \maxweightmatching(\bipartitegraph)\)\;
	\(\alloc \gets \{\, j \given (i, j) \in \matching \,\} \quad\forall i \in \agents\)\tct*{allocate according to matching}
	\(\goodsrem \gets \goods \setminus \{\, j \given (i, j) \in \matching \,\}\)\tct*{remove allocated goods}
	\While{\(\goodsrem \neq \emptyset\)}{
		\(\weights \gets \{\,  \weight{i} \cdot \log\bigl( \valuations[j] + \valuations[\alloc] \bigr) \given[\bigm] i \in \agents, j \in \goodsrem \,\}\)\;
		\(\bipartitegraph \gets (\agents, \goodsrem, \weights)\)\;
		\(\matching \gets \maxweightmatching(\bipartitegraph)\)\;
		\(\alloc \gets \alloc \cup \{\, j \given (i, j) \in \matching \,\} \quad\forall i \in \agents\)\;
		\(\goodsrem \gets \goodsrem \setminus \{\, j \given (i, j) \in \matching \,\}\)\;
	}
	\Return{\(\alloc[][]\)}
	\caption{%
		\SMatch{} for the Asymmetric Additive \NSW{} problem
	}
	\label{alg:smatch}
\end{algorithm*}

\begin{figure*}
	\tikzset{
		lbl/.style = {},
		agent/.style = {draw, circle},
		item/.style = {draw, rectangle},
		dots/.style = {},
		weight/.style = {font=\small},
		edgeopt/.style = {},
		edgealg/.style = {},
		edgegry/.style = {},
		node distance=10mm and 27mm,
	}
	\def\allocationexample{
		\begin{tikzpicture}
			% items
			\node[item, label={[lbl]above:\(\goods\)}] (i1)                       {1};
			\node[item]                                (i2)  [below=of i1]        {2};
			\node[item]                                (i3)  [below=of i2]        {3};
			\node[item]                                (im)  [below=of i3]        {\(m\)};
			\node[item]                                (im1) [below=of im]        {\(m+1\)};
			\node[dots]                                (id)  at ($(i3)!0.5!(im)$) {\(\vdots\)};
			% agents
			\node[agent, label={[lbl]above:\(\agents\)}] (a1) [left=of i1]  {1};
			\node[agent]                                 (a2) [left=of im1] {2};
			% valuations
			\draw[edgealg] (a1) to node[weight, pos=.43, below]      {\(m + \epsilon\)} (i1);
			\draw          (a1) to node[weight, pos=.42, below]      {\(1\)} (i2);
			\draw          (a1) to node[weight, pos=.37, below]      {\(1\)} (i3);
			\draw          (a1) to node[weight, pos=.30, below]      {\(1\)} (im);
			\draw[edgeopt] (a1) to node[weight, pos=.26, below left] {\(1\)} (im1);

			\draw[edgeopt] (a2) to node[weight, pos=.26, above left] {\(m\)} (i1);
			\draw[edgegry] (a2) to node[weight, pos=.30, above]      {\(0\)} (i2);
			\draw[edgegry] (a2) to node[weight, pos=.37, above]      {\(0\)} (i3);
			\draw[edgegry] (a2) to node[weight, pos=.42, above]      {\(0\)} (im);
			\draw[edgealg] (a2) to node[weight, pos=.48, above]      {\(1\)} (im1);
		\end{tikzpicture}
	}
	\centering
	\begin{subfigure}{0.31\textwidth}
		\allocationexample
		\caption{%
			problem instance
			\todo[info]{might delete if document in two columns → unused edges in grey}
		}
	\end{subfigure}
	\hfil
	\begin{subfigure}{0.31\textwidth}
		\tikzset{
			edgealg/.style = {white},
			edgegry/.style = {white},
		}
		\allocationexample
		\caption{%
			\(\OPT = \sqrt{m \cdot m}\)
		}
	\end{subfigure}
	\hfil
	\begin{subfigure}{0.31\textwidth}
		\tikzset{
			edgeopt/.style = {white},
			edgegry/.style = {white},
		}
		\allocationexample
		\caption{%
			\(\ALG \leq \sqrt{(2m + \epsilon - 1) \cdot 1}\)
		}
	\end{subfigure}
	\caption{%
		Agent \(1\) values item \(1\) at \(m + \epsilon\), and all other items at \(1\).
		Agent \(2\) values item \(1\) at \(m\), item \(m+1\) at \(1\), and all other items at \(0\).
		In an optimal allocation, item \(1\) would be assigned to agent \(2\) and all other items to agent \(1\), resulting in a NSW of \(\sqrt{m \cdot m} = m\).
		A repeated maximum matching algorithm would greedily assign item \(1\) to agent \(1\) and item \(m+1\) to agent \(2\) in the first round.
		Even if all remaining items were going to be assigned to agent \(1\), the NSW will never surpass \(\sqrt{(2m + \epsilon - 1) \cdot 1} < \sqrt{2m}\).
		The approximation factor \(\alpha \approx \sqrt{m/2}\) therefore depends on the number of items.
	}
	\label{fig:allocation}
\end{figure*}

\todo[inline]{Ändere Parameterreihenfolge ab und ergänze sinnvolle Säumniswerte}
\todo[inline]{Begrenzer mit Unicode}
\todo[inline]{Begrenzer in Makros}