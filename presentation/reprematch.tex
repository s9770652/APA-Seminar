\section{RepReMatch}

\subsection{Naïve Approach}
\begin{frame}{Naïve Approach}
	\tikzset{
		agent/.style = {draw, circle, font=\small, inner sep=1pt},
		item/.style = {draw, rectangle, font=\small},
		dots/.style = {font=\small},
		weight/.style = {font=\footnotesize},
		edgeopt/.style = {},
		edgealg/.style = {},
		edgegry/.style = {},
		node distance=12mm and 32mm,
		on grid
	}
	\def\allocationexample{
		\centering
		\begin{tikzpicture}
			% items
			\node[item] (i1)                       {\(\goods_{1}\)};
			\node[item] (i2)  [below=of i1]        {\(\goods_{2}\)};
			\node[item] (i3)  [below=of i2]        {\(\goods_{3}\)};
			\node[item] (im)  [below=of i3]        {\(\goods_{m}\)};
			\node[item] (im1) [below=of im]        {\(\goods_{m+1}\)};
			\node[dots] (id)  at ($(i3)!0.5!(im)$) {\(\vdots\)};
			% agents
			\node[agent] (a1) [left=of i1]  {\(\agents_1\)};
			\node[agent] (a2) [left=of im1] {\(\agents_2\)};
			% valuations
			\draw[edgealg] (a1) to node[weight, pos=.42,  above]      {\(m + \epsilon\)} (i1);
			\draw          (a1) to node[weight, pos=.42,  above]      {\(1\)}            (i2);
			\draw          (a1) to node[weight, pos=.39,  above]      {\(1\)}            (i3);
			\draw          (a1) to node[weight, pos=.32,  above]      {\(1\)}            (im);
			\draw[edgeopt] (a1) to node[weight, pos=.255, above]      {\(1\)}            (im1);

			\draw[edgeopt] (a2) to node[weight, pos=.26,  above left] {\(m\)}            (i1);
			\draw[edgegry] (a2) to node[weight, pos=.30,  above]      {\(0\)}            (i2);
			\draw[edgegry] (a2) to node[weight, pos=.37,  above]      {\(0\)}            (i3);
			\draw[edgegry] (a2) to node[weight, pos=.42,  above]      {\(0\)}            (im);
			\draw[edgealg] (a2) to node[weight, pos=.48,  above]      {\(1\)}            (im1);
		\end{tikzpicture}
	}
	\begin{center}
		\allocationexample
	\end{center}
	\begin{block}{}
		What are the low-value items?\phantom{g}  % 'g' has an ascender.
	\end{block}
\end{frame}

\begin{frame}{Looking into the Future}
	\begin{itemize}
		\item
		sort items by valuation in descending order
		\begin{itemize}
			\item
			low-value items on the left
		\end{itemize}
	\end{itemize}
	\begin{center}
		\includegraphics[width=10cm, height=2cm, page=21]{example-image-duck}
	\end{center}
	\begin{itemize}
		\item
		use their valuations for edge weights in early matchings
	\end{itemize}
	\begin{exampleblock}{}
		A \(2n\)-approximation is possible \dots{} using \SMatch.
	\end{exampleblock}
	\begin{alertblock}{}
		This only works for additive valuation functions.
	\end{alertblock}
\end{frame}

\begin{frame}{Changing the Past}
	Under submodular valuation, the set of lowest valuation is approximable only by \(\bigomega\paren[\big]{ \sqrt{m/\ln m} }\).
	\includegraphics[height=3ex, page=66]{example-image-duck}

	We can change the past in three phases:
	\begin{description}
		\item[Phase \phasei]
		Assign enough high-value items temporarily.

		\item[Phase \phaseii]
		Assign the remaining items definitely.

		\item[Phase \phaseiii]
		Re-assign the items of phase \phasei{} definitely.
	\end{description}
	\begin{center}
		\includegraphics[height=3cm, page=43]{example-image-duck}
	\end{center}
	\begin{exampleblock}{}
		A \(2n (\log_2 n + 3)\)-approximation is possible!
	\end{exampleblock}
\end{frame}

\subsection{The Algorithm}
\begin{frame}{The Algorithm}
	Phase \phasei
	\begin{enumerate}
		\item
		repeat \(\ceil{\log_2 n} + 1\) times or until \(\goods = \emptyset\)
		\begin{enumerate}
			\item
			create bipartite graph \(\bipartitegraph = (\agents, \goods, E)\) with edge weights \(\edgeweight{i, j} = \weight \log \valuations[ \{ j \} ]\)

			\item
			compute maximum weight matching \(\matching\)

			\item
			update bundles \(\alloc[\phasei]\) according to matching \(\matching\) \& remove assigned items
		\end{enumerate}
		\seti
	\end{enumerate}
	Phase \phaseii
	\begin{enumerate}
		\conti
		\item
		repeat until \(\goods = \emptyset\)
		\begin{enumerate}
			\item
			create bipartite graph \(\bipartitegraph = (\agents, \goods, E)\) with edge weights \(\edgeweight{i, j} = \weight \log \paren[\big]{ \valuations[\alloc[\phaseii] \cup \{ j \} ] }\)

			\item
			compute maximum weight matching \(\matching\)

			\item
			update bundles \(\alloc[\phaseii]\) according to matching \(\matching\) \& remove assigned items
		\end{enumerate}
		\seti
	\end{enumerate}
	Phase \phaseiii
	\begin{enumerate}
		\conti
		\item
		create bipartite graph \(\bipartitegraph = (\agents, \bigcup_{i \in \agents} \alloc[\phasei], E)\) with edge weights \(\edgeweight{i, j} = \weight \log \paren[\big]{ \valuations[\alloc[\phaseii] \cup \{ j \} ] }\)

		\item
		compute maximum weight matching \(\matching\)

		\item
		create bundles \(\alloc[\phaseiii]\) according to matching \(\matching\) and previous bundles \(\alloc[\phaseii]\)
	\end{enumerate}
\end{frame}

\subsection{Analysing Phase \phaseii}
\begin{frame}{Analysing Phase \phaseii{} (1/3)}
	\adjustfortopblock
	\begin{definition}
		The set \(\lostset{r}\) of \emph{lost items} is the set of all items \(j \in \alloc*\) assigned to other agents \(i' \neq i\) in round \(r\).
	\end{definition}
	\begin{definition}
		The set of \emph{optimal and attainable items} is defined as
		\begin{equation*}
			\attopt{r} \coloneq \begin{cases*}
				\alloc* \setminus \bigcup_{i' \in \agents} \alloc[\phasei][i'] & in round \(r = 0\), \\
				\attopt{0} \setminus \lostset{1} & in round \(r = 1\), \\
				\attopt{r-1} \setminus ( \lostset{r} \cup \{\asgd{r-1}\} & in round \(r = 2, \dots, \alloclen[\phaseii]\).
			\end{cases*}
		\end{equation*}
	\end{definition}
	\begin{center}
		\includegraphics[height=2cm, page=25]{example-image-duck}
	\end{center}
\end{frame}

\begin{frame}{Analysing Phase \phaseii{} (2/3)}
	\begin{lemma}
		For each agent \(i \in \agents\) and her bundle \(\alloc[\phaseii] = \{ \asgd{1}, \dots, \asgd{\alloclen[\phaseii]} \}\) at the end of phase \phaseii, it holds in all rounds \(r = 2, \dots, \alloclen[\phaseii]\) that
		\vspace{-2ex}
		\begin{equation*}
			\valuations[ \attopt{r} \given \asgd{1}, \dots, \asgd{r-1} ] \ge \valuations[\attopt{1}] - \smashoperator{\sum_{r'=1}^{r-1}} \lostsetlen{r'+1} \cdot \valuations[ \asgd{r'} \given \asgd{1}, \dots, \asgd{r'-1} ] - \valuations[\asgd{1}, \dots, \asgd{r-1}] \mperiod \vspace{-0.5ex}
		\end{equation*}
	\end{lemma}
\end{frame}